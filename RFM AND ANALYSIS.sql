

 --------------------customer percent by regions

select Region,
round((count(distinct Customer_id)*100.0/96803),2) customer_percent
from Finalised_Records
group by Region
order by customer_percent desc


------------customer bt state

select customer_state,count(Customer_id) customer
from customer_360
group by customer_state
order by customer desc

-------CUSTOMER BY GENDER


select Gender,count(Customer_id) TOTAL_customer,
ROUND(sum(revenue),2) REVENUE,
ROUND(SUM(total_discount),2) DISCOUNT,
SUM(no_of_transaction) TOTAL_ORDERS
from customer_360
group by Gender 

SELECT * FROM customer_360
--- Customer Brehaviour And RFM segmentation

-- value based segmentation

select * from customer_360
where revenue > 7000

alter table customer_360
add r_score tinyint, f_score tinyint, m_score tinyint

ALTER TABLE CUSTOMER_360
ADD FINAL_SCORE TINYINT

ALTER TABLE CUSTOMER_360
ADD VALUE_SEGMENT VARCHAR(30)

--UPDATE customer_360
--SET VALUE_SEGMENT=case WHEN revenue >= 7000 THEN 'DIAMOND'
--    WHEN revenue BETWEEN 3000 AND 7000 THEN 'GOLD'
--    WHEN revenue BETWEEN 1000 AND 3000 THEN 'SILVER'
--    ELSE 'BRONZE'
--end 
--
---rfm
SELECT * FROM customer_360

------------- R score------------
UPDATE customer_360
SET r_score = case when inactive_days <90 then 4
when inactive_days between 90 and 180 then 3
when inactive_days between 180 and 270 then 2
else 1
end


-------------------F score  -----------
UPDATE customer_360
SET F_SCORE= case when no_of_transaction >=5 then 4
when no_of_transaction between 3 and 5 then 3
when no_of_transaction =2 then 2
else 1
end 


------------ M score --------------
UPDATE customer_360
SET M_SCORE=case WHEN revenue >= 1000 THEN  4
    WHEN revenue BETWEEN 300 AND 1000 THEN 3
    WHEN revenue BETWEEN 150 AND 300 THEN 2
    ELSE 1
end 

----------- FINAL SCORE
UPDATE customer_360
SET FINAL_SCORE=R_SCORE+F_SCORE+M_SCORE

---------------------------- ANALYSIIS

SELECT M_SCORE,
    COUNT(customer_id) AS customer_count,
    ROUND((COUNT(customer_id) * 100.0 / SUM(COUNT(customer_id)) OVER ()),2) AS percent_of_customers
FROM customer_360
GROUP BY M_SCORE
ORDER BY customer_count desc


SELECT M_SCORE,
    SUM(total_qty) AS QUANTITY,
    ROUND((SUM(total_qty) * 100.0 / SUM(SUM(total_qty)) OVER ()),2) AS percent_of_QUANTITY
FROM customer_360
GROUP BY M_SCORE
ORDER BY QUANTITY DESC

----------- revenue and profit by (m_score)

SELECT M_SCORE,
    ROUND(SUM(revenue),2) TOTAL_REVENUE, 
	ROUND(SUM(profit_per_cust),2)PROFIT,
    ROUND((SUM(revenue) * 100.0 / SUM(SUM(revenue)) OVER ()),2) AS percent_of_REVENUE
FROM customer_360
GROUP BY M_SCORE
ORDER BY TOTAL_REVENUE DESC

------------ RFM SEGMENTATION

SELECT customer_id,first_purchase,last_purchase,revenue,r_score,f_score,m_score,FINAL_SCORE,
CASE 
	WHEN FINAL_SCORE >= 8 THEN 'PREMIMUM'
	WHEN FINAL_SCORE BETWEEN 6 AND 8 THEN 'GOLD'
	WHEN FINAL_SCORE BETWEEN 4 AND 6 THEN 'SILVER'
	ELSE 'STANDARD'
END RFM_SEGMENT --into RFM_TABLE
from customer_360

----customers by rfm_segments
select rfm_segment,count(R.customer_id) customer_count,
round(count(R.customer_id)*100.0/sum(count(R.customer_Id))over(),2) cust_percent,
SUM(C.no_of_transaction) ORDERS,
ROUND(SUM(R.revenue),2) REVENUE
from rfm_table R
JOIN customer_360 C
ON R.customer_id=C.Customer_id
group by rfm_segment

------ Customer revenue by rfm segment
select rfm_segment,round(sum(revenue),2) revenue 
from rfm_table
group by rfm_segment
order by revenue desc

--============================== DISCOUNT SEEKER VS NON DISCOUNT SEEKER

------- discount seeker, non discount seeker,  ONE TIME BUYER

SELECT 
    COUNT(CASE WHEN No_of_transactions_with_discount = 0 THEN 1 END) AS discount_seeker_cust,
    COUNT(CASE WHEN No_of_transactions_with_discount <> 0 THEN 1 END) AS non_discount_seeker_cust,
	count(CASE WHEN no_of_transaction=1 THEN 1 END) AS ONE_TIME_BUYER,
	count(CASE WHEN no_of_transaction<> 1 THEN 1 END) AS REPEATED_BUYER,
	count(CASE WHEN transaction_with_voucher<>0 THEN 1 END) AS TRANSACTION_WITH_VOUCHER,
	count(CASE WHEN no_of_channel_for_purchase<>1 THEN 1 END) AS CUSTOMER_WITH_MULTIPLE_CHANNEL
FROM customer_360

--------- ONE TIME BUYERS BY STATE

SELECT customer_state ,COUNT(*) NO_OF_CUSTOMERS 
FROM customer_360
WHERE no_of_transaction=1
GROUP BY customer_state
ORDER BY NO_OF_CUSTOMERS

------repeated buyers
SELECT customer_state ,COUNT(*) NO_OF_CUSTOMERS 
FROM customer_360
WHERE no_of_transaction<>1
GROUP BY customer_state
ORDER BY NO_OF_CUSTOMERS

------------- REVENUE GENERATED BY ONE TIME BUYERS

SELECT year(Bill_date_timestamp) YEARS,
datename(month,Bill_date_timestamp) MONTHS,
SUM(revenue) REVENUE,SUM(profit_per_cust) PROFIT
from customer_360 C JOIN Finalised_Records F
ON C.Customer_id=F.Customer_id
WHERE no_of_transaction=1
GROUP BY year(Bill_date_timestamp),datename(month,Bill_date_timestamp)
ORDER BY YEARS

----- REVENUE GENERATED BY repeated buyers
SELECT year(Bill_date_timestamp) YEARS,
datename(month,Bill_date_timestamp) MONTHS,
SUM(revenue) REVENUE,SUM(profit_per_cust) PROFIT
from customer_360 C JOIN Finalised_Records F
ON C.Customer_id=F.Customer_id
WHERE C.Customer_id in(select Customer_id from customer_360 
WHERE no_of_transaction>1)
GROUP BY year(Bill_date_timestamp),datename(month,Bill_date_timestamp)
ORDER BY YEARS


-----------------=============================== DISCOUNT/NON-DISCOUNT 

------------- AVG ORDER  FROM DISCOUNT SEEKER AND NON DISCOUNT SEEKER


select *,ROUND(REVENUE_DISCOUNT_SEEKER/discount_seeker_cust,2) AVG_ORDER_DISCOUNT_SEEKER,
ROUND(REVENUE_NON_DISCOUNT_SEEKER/non_discount_seeker_cust,2) AVG_ORDER_NON_DISCOUNT_SEEKER
from 
(
SELECT 
	COUNT(CASE WHEN No_of_transactions_with_discount = 0 THEN 1 END) AS discount_seeker_cust,
    COUNT(CASE WHEN No_of_transactions_with_discount <> 0 THEN 1 END) AS non_discount_seeker_cust,
	sum(CASE WHEN No_of_transactions_with_discount = 0 THEN total_qty END) AS discount_seeker_quantity,
    SUM(CASE WHEN No_of_transactions_with_discount <> 0 THEN total_qty END) AS non_discount_seeker_quantity,
    ROUND(SUM(CASE WHEN No_of_transactions_with_discount = 0 THEN revenue ELSE 0 END) ,2)AS  REVENUE_NON_DISCOUNT_SEEKER,
    ROUND(SUM(CASE WHEN No_of_transactions_with_discount <> 0 THEN revenue ELSE 0 END),2) AS REVENUE_DISCOUNT_SEEKER,
	ROUND(SUM(CASE WHEN No_of_transactions_with_discount = 0 THEN profit_per_cust ELSE 0 END) ,2)AS PROFIT_NON_DISCOUNT_SEEKER,
    ROUND(SUM(CASE WHEN No_of_transactions_with_discount <> 0 THEN profit_per_cust ELSE 0 END),2) PROFIT_DISCOUNT_SEEKER
FROM customer_360
) as x

-------------------- STATE WISE CUSTOMERS DISCOUNT SEEKER
select customer_state,count(*) customer 
from customer_360
WHERE No_of_transactions_with_discount <> 0
group by customer_state
order by customer desc

-------- REGION WISE CUSTOMERS DISCOUNT SEEKER
select Region,count(*) customer 
from customer_360 c join Finalised_Records f
on c.Customer_id=f.Customer_id
WHERE No_of_transactions_with_discount <> 0
group by Region
order by customer desc

----- STATE WISE NON DISCOUNT SEEKER
select customer_state,count(*) customer 
from customer_360
WHERE No_of_transactions_with_discount = 0
group by customer_state
order by customer desc

-------- REGION WISE CUSTOMERS NON-DISCOUNT 
select Region,count(C.Customer_id) customer 
from customer_360 c join Finalised_Records f
on c.Customer_id=f.Customer_id
WHERE No_of_transactions_with_discount = 0
group by Region
order by customer desc


----------=======================SELLER WISE ANALYSIS

------------ seller preferences

SELECT seller_state,count(distinct Customer_id) no_of_Cust
FROM Finalised_Records
group by seller_state
order by no_of_Cust desc

----- payment method used 
SELECT payment_type,count(distinct Customer_id) no_of_Cust
FROM Finalised_Records f join payments p
on f.order_id=p.order_id
group by payment_type
order by no_of_Cust desc


---------------------------------------------------------------------------------------------------------
-------------------------TREND ANALYSIS--------------------------------------

----- SALES TRENDS ANALYSIS 
SELECT YEAR(Bill_date_timestamp) YEARS, DATENAME(MONTH,Bill_date_timestamp) MONTHS,
MONTH(Bill_date_timestamp) M,
ROUND(SUM(Total_Amount),2) REVENUE,
ROUND(SUM(Total_Amount)*100/SUM(SUM(Total_Amount)) OVER(),4) SALE_PERCENT
FROM order_360
GROUP BY YEAR(Bill_date_timestamp),DATENAME(MONTH,Bill_date_timestamp),MONTH(Bill_date_timestamp)
ORDER BY YEARS,M

--MONTH ON MONTH TREND
SELECT  DATENAME(MONTH,Bill_date_timestamp) MONTHS,
MONTH(Bill_date_timestamp) M,
ROUND(SUM(Total_Amount),2) REVENUE,
ROUND(SUM(Total_Amount)*100/SUM(SUM(Total_Amount)) OVER(),4) SALE_PERCENT
FROM order_360
GROUP BY DATENAME(MONTH,Bill_date_timestamp),MONTH(Bill_date_timestamp)
ORDER BY M

-- WEEKDAY VS WEEKEND trend
SELECT  DATENAME(WEEKDAY,Bill_date_timestamp) MONTHS,
DATEPART(WEEKDAY,Bill_date_timestamp) w,
ROUND(SUM(Total_Amount),2) REVENUE,
ROUND(SUM(Total_Amount)*100/SUM(SUM(Total_Amount)) OVER(),2) SALE_PERCENT
FROM order_360
GROUP BY DATENAME(WEEKDAY,Bill_date_timestamp),DATEPART(WEEKDAY,Bill_date_timestamp)
ORDER BY W


---------- by datetime trend
SELECT
DATEPART(HOUR,Bill_date_timestamp) h,
ROUND(SUM(Total_Amount),2) REVENUE,
ROUND(SUM(Total_Amount)*100/SUM(SUM(Total_Amount)) OVER(),2) SALE_PERCENT
FROM order_360
GROUP BY DATEPART(HOUR,Bill_date_timestamp)
ORDER BY h


--===================RATING ANALYSIS=================
---------   Avg rating by state
select customer_state,round(avg(Avg_rating*1.0),2) avg_rating 
from Finalised_Records
group by customer_state
order by avg_rating desc

------------- Avg rating by products
select category,round(avg(Avg_rating*1.0),2) avg_rating 
from Finalised_Records
group by Category
order by avg_rating desc


------------------------------------------------------=====



--==== Missing: Cross-category analysis (how many categories are shopped in a bill by region/state).


-- Average Number of Categories per Order
SELECT COUNT(category)*1.0 / COUNT(DISTINCT order_id) AS Avg_Categories_Per_Order 
FROM Finalised_Records

-- Average Number of Items per Order
SELECT SUM(quantity)*1.0 / COUNT(DISTINCT order_id) AS Avg_Items_Per_Order FROM order_360;


--========================



-- Repeat Purchase Rate
SELECT COUNT( Customer_id)*1.0 / (SELECT COUNT( Customer_id) FROM customer_360) * 100 AS Repeat_Purchase_Rate 
FROM (SELECT Customer_id FROM customer_360 where no_of_transaction > 1) AS Repeat_Customers;

-- Repeat Customer Percentage
SELECT (COUNT(DISTINCT Customer_id) * 1.0 / (SELECT COUNT(DISTINCT Customer_id) FROM customer_360)) * 100 AS One_Time_Buyers_Percentage
FROM customer_360 
WHERE no_of_transaction > 1;

-- One-Time Buyers Percentage
SELECT 
    (COUNT(DISTINCT Customer_id) * 1.0 / (SELECT COUNT(DISTINCT Customer_id) FROM customer_360)) * 100 AS One_Time_Buyers_Percentage
FROM customer_360 
WHERE no_of_transaction = 1;

-- Identifying top 10 frequently bought together products

select top 10 product_id,count(order_id) frequently_order from 
Finalised_Records
group by product_id
order by frequently_order desc

-- Category Penetration Analysis
SELECT category, 
round(COUNT(distinct order_id)*1.0 / (SELECT COUNT(distinct order_id) FROM Finalised_Records) * 100,2) AS Category_Penetration 
FROM Finalised_Records 
group by Category
order by Category_Penetration desc


select * from Finalised_Records

-- Cross-Category Analysis (Average categories per transaction by region)
select A.category as cat1,B.category as cat2, count(distinct A.order_id) frequency from 
Finalised_Records A join finalised_Records B
on A.order_id=B.order_id and A.category <> B.category
group by A.Category,B.Category
order by frequency desc


------useing that find the product purchased together(cross selling product)
SELECT A.category,A.product_id AS Product1, B.Category,B.product_id AS Product2, COUNT(DISTINCT A.order_id) AS Frequency
FROM Finalised_Records A
JOIN Finalised_Records B ON A.order_id = B.order_id AND A.product_id <> B.product_id and A.category <> B.category
GROUP BY A.Category,A.product_id, B.product_id,B.Category
ORDER BY Frequency DESC;



-----finding the cross selling probability
SELECT distinct A.product_id AS Product1, B.product_id AS Product2, 
COUNT(DISTINCT A.order_id)*100.0/(select count (distinct order_id) from Finalised_Records where product_id=A.product_id) AS cross_sell_probability
FROM Finalised_Records A
JOIN Finalised_Records B ON A.order_id = B.order_id AND A.product_id <> B.product_id
GROUP BY A.product_id, B.product_id
ORDER BY cross_sell_probability DESC;





-- Most popular category during first purchase


